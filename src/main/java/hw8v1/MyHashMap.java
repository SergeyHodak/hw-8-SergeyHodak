package hw8v1;

/*
    Задание 5 - HashMap#
    Написать свой класс MyHashMap как аналог классу HashMap.

    Нужно делать с помощью односвязной Node.

    Не может хранить две ноды с одинаковых ключами одновременно.

    Методы

    put(Object key, Object value) добавляет пару ключ + значение
    remove(Object key) удаляет пару по ключу
    clear() очищает коллекцию
    size() возвращает размер коллекции
    get(Object key) возвращает значение(Object value) по ключу
 */


import java.io.OptionalDataException;

public class MyHashMap<K, V> {
    private Node<K, V>[] table; // массив, для хранения пар «ключ-значение» в виде узлов
//    int size; // количество пар «ключ-значение»
//    int threshold; // предельное количество элементов, при достижении которого размер хэш-таблицы увеличивается вдвое
//    // Рассчитывается по формуле (capacity * loadFactor)
//    final float loadFactor; // при какой степени загруженности текущей хеш-таблицы необходимо создавать новую
//    // хеш-таблицу, т.е. как только хеш-таблица заполнилась на 75%, будет создана новая хеш-таблица с перемещением в
//    // неё текущих элементов (затратная операция, так как требуется перехеширование всех элементов)
//    Set<Map.Entry<K,V>> entrySet; //содержит кешированный entrySet(), с помощью которого мы можем перебирать HashMap
//
//    //константы:
//    static final int DEFAULT_INITIAL_CAPACITY = 16; /// емкость хеш-таблицы по умолчанию (16)
//    static final int MAXIMUM_CAPACITY = 1_000; // максимально возможная емкость хеш-таблицы
//    static final float DEFAULT_LOAD_FACTOR = 0.9f; // коэффициент загрузки, используемый по умолчанию
//    static final int TREEIFY_THRESHOLD = 8; //это «порог» количества элементов в одной корзине, при достижении
//    // которого внутренний связный список будет преобразован в древовидную структуру (красно-черное дерево).
//    static final int UNTREEIFY_THRESHOLD = 6; // если количество элементов в одной корзине уменьшится до 6, то
//    // произойдет обратный переход от дерева к связному списку;
//    static final int MIN_TREEIFY_CAPACITY = 64; // минимальная емкость (количество корзин) хеш-таблицы, при которой
//    // возможен переход к древовидной структуре. Т.е. если в хеш-таблице по крайней мере 64 бакета и в одном бакете
//    // 8 или более элементов, то произойдет переход к древовидной структуре.
//
//    // Конструкторы класса:
//    public MyHashMap() {} // создает хеш-отображение по умолчанию: объемом (capacity) = 16 и с коэффициентом
//    // загруженности (load factor) = 0.9;
//    public MyHashMap(Map< ? extends K, ? extends V> m) {} // создает хеш-отображение, инициализируемое элементами
//    // другого заданного отображения с той начальной емкостью, которой хватит вместить в себя элементы другого отображения;
//    public MyHashMap(int initialCapacity) {} // создает хеш-отображение с заданной начальной емкостью. Для корректной и
//    // правильной работы HashMap размер внутреннего массива обязательно должен быть степенью двойки (т.е. 16, 64, 128 и т.д.);
//    public MyHashMap(int initialCapacity, float loadFactor) {} // создает хеш-отображение с заданными параметрами:
//    // начальной емкостью и коэффициентом загруженности.
//
    class Node<K, V> { // клас создающий ноды
        K key; // ключ текущего элемента
        V value; // значение текущего элемента
        int hash; // хеш текущего элемента
        Node<K, V> next; // ссылка на следующий узел в пределах одной корзины.

        public void setNode(K key, V value) { // метод устанавливающий ключ и значение
            this.key = key; // ключ
            this.value = value; // значение

        }

        private void hash(Object key) {
            int h; // изначально хешь пусть будет пустым, по дефолту нуль
            hash = (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); // если значение не нул, воспользуемся стандартным хешь методом
        }


        private int buckets(int hash) { // получить индекс корзины для данных
            return  (table.length - 1) & hash; // длина массива и хеш
        }
    }

    public static void main(String[] args) {
        MyHashMap<String, Integer> test = new MyHashMap<String, Integer>();
    }
}